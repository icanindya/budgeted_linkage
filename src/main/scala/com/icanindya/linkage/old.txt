/* ------------------------------------------------------------- */

//  val datasetSizes = Array(1.0, 10000.0, 10000.0, 10000.0, 10000.0)
//
//  var master, cor5D1, cor5D2, cor5D3, cor5D4, cor5D5, cor10D1, cor10D2, cor10D3, cor10D4, cor10D5 = List[Array[String]]()
//  var cor5 = Array[List[Array[String]]]()
//  var cor10 = Array[List[Array[String]]]()
//
//  val datasetParams = List((1000, 4), (10000, 4), (100000, 4), (1000000, 4))
//  val LEVENSHTEIN_DIST_THRES = 1

/* ------------------------------------------------------------- */

//  def test(sc: SparkContext, option: String) {
//    val testSamples = Random.shuffle(master.toList).take(500)
//  }
//
//  def getAccuracyNormalJoin(sc: SparkContext, testSamples: List[Array[String]], option: String) {
//
//    for (path <- getAllPaths(0, 5)) {
//
//      val successCountK = Array.fill[Int](5)(0)
//
//      for (sample <- testSamples) {
//
//        val origAge = sample(attrIndex("age"))
//
//        var ldb = List(sample)
//        var attrSoFar = dsAttrs(path(0))
//
//        for (i <- 0 to path.length - 2) {
//
//          var rdb = if (option == "cor5") cor5(path(i + 1) - 1)
//          else if (option == "cor10") cor10(path(i + 1) - 1)
//          else master
//          val commonAttr = attrSoFar.intersect(dsAttrs(path(i + 1)))
//
//          var jdb = ListBuffer[Array[String]]()
//          for (lTuple <- ldb) {
//            for (rTuple <- rdb) {
//              if (equal(lTuple, rTuple, commonAttr, option)) {
//                jdb += rTuple
//              }
//            }
//          }
//          attrSoFar = attrSoFar.union(dsAttrs(path(i + 1)))
//          ldb = jdb.toList
//        }
//
//        val ages = ldb.map { tuple =>
//          tuple(attrIndex("age"))
//        }.groupBy(identity).mapValues { _.size }.toSeq.sortBy(x => x._2 > x._2).map(_._1)
//
//        for {
//          k <- 0 to successCountK.length - 1
//          if (k < ages.length)
//        } {
//          if (ages(k) == origAge) {
//            for (i <- k to successCountK.length - 1) {
//              successCountK(i) += 1
//            }
//          }
//        }
//        //        println("final size " + ldb.length)
//      }
//
//      println("path: %s".format(path.mkString(" - ")))
//      println("accuracy: %s".format(successCountK.map(x => (x * 100) / testSamples.length).mkString(",")))
//
//    }
//
//  }
//
//  def getAccuracyProbabilisticJoin(sc: SparkContext, testSamples: List[Array[String]], option: String) {
//
//    for (path <- getAllPaths(0, 5)) {
//      println("path: %s".format(path.mkString(" - ")))
//      for (k <- 1 to 5) {
//
//        val successCountK = Array.fill[Int](5)(0)
//        var success = 0
//        var lengthSum = 0
//        for (sample <- testSamples) {
//
//          val origAge = sample(attrIndex("age"))
//          var ldb = List((sample, 1.0))
//
//          for (i <- 0 to path.length - 2) {
//            val rdb = if (option == "cor5") cor5(path(i + 1) - 1)
//            else if (option == "cor10") cor10(path(i + 1) - 1)
//            else master
//            val commonAttr = dsAttrs(path(i)).intersect(dsAttrs(path(i + 1)))
//
//            val ldbTotalScore = ldb.map(_._2).sum
//
//            val distinctKeyValueScores = ldb.map { ts =>
//              val tuple = ts._1
//              val score = ts._2
//              val keyValue = tupleToCommonAttrMap(tuple, commonAttr)
//              (keyValue, score)
//            }
//              .groupBy(_._1).mapValues(_.map(_._2).sum / ldbTotalScore)
//              .toSeq.sortBy(x => x._2 > x._2).take(k)
//
//            var jdb = ListBuffer[(Array[String], Double)]()
//            for (lKeyValueScore <- distinctKeyValueScores) {
//              for (rTuple <- rdb) {
//                val lKeyValue = lKeyValueScore._1
//                val lScore = lKeyValueScore._2
//                val rKeyValue = tupleToCommonAttrMap(rTuple, commonAttr)
//                if (probEqual(lKeyValue, rKeyValue, option)) {
//                  jdb += ((rTuple, lScore))
//                }
//              }
//            }
//            ldb = jdb.toList
//          }
//
//          val agesAll = ldb.map { tupleScore =>
//            val tuple = tupleScore._1
//            val score = tupleScore._2
//            (tuple(attrIndex("age")), score)
//          }
//            .groupBy(_._1).mapValues(_.map(_._2).sum)
//            .toSeq.sortBy(x => x._2 > x._2).map(_._1)
//
//          lengthSum += agesAll.length
//
//          val ages = agesAll.take(k)
//
//          if (ages.contains(origAge)) success += 1
//
//        }
//        println("length: " + lengthSum.toDouble / testSamples.length)
//        println("accuracy for k = %d: %d".format(k, (success * 100) / testSamples.length))
//      }
//    }
//  }
//
//  def probEqual(lKeyValue: Map[String, String], rKeyValue: Map[String, String], option: String): Boolean = {
//    var probEqual = true
//    for (lKey <- lKeyValue.keys) {
//      if (option != "master") {
//        if (lKey == "first_name" || lKey == "last_name") {
//          if (LevenshteinMetric.compare(lKeyValue(lKey), rKeyValue(lKey)).get > LEVENSHTEIN_DIST_THRES) probEqual = false
//        } else {
//          if (lKeyValue(lKey) != rKeyValue(lKey)) probEqual = false
//        }
//      } else {
//        if (lKeyValue(lKey) != rKeyValue(lKey)) probEqual = false
//      }
//    }
//    probEqual
//  }
//
//  def equal(lTuple: Array[String], rTuple: Array[String], commonAttr: List[String], option: String): Boolean = {
//    var equal = true
//    for {
//      attr <- commonAttr
//      if (equal == true)
//    } {
//      if (option != "master") {
//        if (attr == "first_name" || attr == "last_name") {
//          //          println(lTuple.mkString(",") + " " + rTuple.mkString(","))
//          if (LevenshteinMetric.compare(lTuple(attrIndex(attr)), rTuple(attrIndex(attr))).get > LEVENSHTEIN_DIST_THRES) equal = false
//        } else {
//          if (lTuple(attrIndex(attr)) != rTuple(attrIndex(attr))) equal = false
//        }
//      } else {
//        if (lTuple(attrIndex(attr)) != rTuple(attrIndex(attr))) equal = false
//      }
//    }
//    equal
//  }
//
//  def tupleToCommonAttrMap(tuple: Array[String], commonAttr: List[String]): Map[String, String] = {
//    var keyValue = Map[String, String]()
//    for (attr <- commonAttr) {
//      keyValue += (attr -> tuple(attrIndex(attr)))
//    }
//    keyValue
//  }